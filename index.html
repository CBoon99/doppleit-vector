<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:">
    <title>Doppleit Vector</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #e37800;
            --glow-color: #ffb340;
            --gradient: linear-gradient(90deg, #e37800, #ffb340);
            --shadow-glow: 0 0 10px rgba(255, 191, 64, 0.4);
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #1a1a1a 0%, #2a2a40 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #header {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #header h1 {
            font-size: 24px;
            font-weight: 700;
            margin: 0;
            text-shadow: var(--shadow-glow);
        }
        #status {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        #status::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            margin-right: 6px;
        }
        #toolbar {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            align-items: center;
        }
        .tool-btn, .export-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 8px;
            background: var(--gradient);
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-btn:hover, .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-glow);
        }
        .tool-btn:active, .export-btn:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .tool-btn.active {
            background: #ffb340;
            box-shadow: var(--shadow-glow);
        }
        .tool-btn svg, .export-btn svg {
            width: 18px;
            height: 18px;
            fill: #fff;
        }
        .tool-btn:hover svg, .export-btn:hover svg {
            fill: #fff;
        }
        .divider {
            width: 1px;
            background: rgba(255, 255, 255, 0.2);
            align-self: stretch;
            margin: 0 8px;
        }
        #colorPicker {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
        }
        #colorCanvas {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: crosshair;
            clip-path: circle(40px at center);
            aspect-ratio: 1 / 1;
        }
        #lightnessSlider {
            width: 20px;
            height: 80px;
            border-radius: 4px;
            cursor: pointer;
        }
        #colorInputs {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        #colorInputs input {
            padding: 4px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 12px;
            width: 100px;
        }
        #swatches {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        .swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .swatch:hover {
            transform: scale(1.1);
        }
        #toolOptions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        #toolOptions h4 {
            margin: 0;
            font-size: 13px;
            font-weight: 600;
        }
        #toolOptions label {
            font-size: 12px;
            margin-right: 4px;
        }
        #toolOptions input, #toolOptions select {
            padding: 4px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 12px;
        }
        #exportOptions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        #filenameInput {
            padding: 4px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 12px;
            width: 150px;
        }
        #canvasContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            overflow: auto;
            position: relative;
        }
        #canvas {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        #dropZone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            text-align: center;
            color: #fff;
            font-size: 16px;
            z-index: 10;
            display: none;
        }
        #dropZone.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #footer {
            padding: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
            font-size: 12px;
            color: #cccccc;
        }
        #footer a {
            color: var(--glow-color);
            text-decoration: none;
            margin: 0 10px;
        }
        #footer a:hover {
            text-decoration: underline;
        }
        .tooltip {
            position: relative;
        }
        .tooltip::after {
            content: attr(title);
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
            backdrop-filter: blur(10px);
        }
        .tooltip:hover::after {
            opacity: 1;
        }
        @media (min-width: 1024px) {
            #colorPicker {
                flex-direction: column;
                align-items: flex-start;
            }
            #colorInputs, #swatches {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        @media (max-width: 768px) {
            #header, #toolbar, #canvasContainer {
                padding: 12px;
            }
            #header h1 {
                font-size: 20px;
            }
            #colorCanvas, #lightnessSlider {
                width: 60px;
                height: 60px;
            }
            #colorInputs input {
                width: 80px;
            }
            #toolOptions {
                flex-wrap: wrap;
            }
            #filenameInput {
                width: 120px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            <h1>Doppleit Vector</h1>
            <div id="status">Online</div>
        </div>
        <div id="toolbar">
            <button class="tool-btn active tooltip" data-tool="pen" title="Pen Tool" aria-label="Pen Tool">
                <svg viewBox="0 0 24 24"><path d="M3 17v4h4l14-14-4-4z"/></svg>
                Pen
            </button>
            <button class="tool-btn tooltip" data-tool="shape" title="Shape Tool" aria-label="Shape Tool">
                <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16"/></svg>
                Shape
            </button>
            <input type="file" id="importImage" accept="image/png, image/jpeg, image/svg+xml" style="display: none;">
            <button class="tool-btn tooltip" id="importBtn" title="Import Image" aria-label="Import Image">
                <svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5zm0-10l7-7 7 7h-4v6h-6v-6H5z"/></svg>
                Import
            </button>
            <div class="divider"></div>
            <div id="colorPicker">
                <div style="display: flex; gap: 8px;">
                    <canvas id="colorCanvas" width="80" height="80"></canvas>
                    <canvas id="lightnessSlider" width="20" height="80"></canvas>
                </div>
                <div id="colorInputs">
                    <input id="hexInput" placeholder="HEX" aria-label="HEX Color Input">
                    <input id="hslInput" placeholder="HSL" aria-label="HSL Color Input">
                    <input id="rgbInput" placeholder="RGB" aria-label="RGB Color Input">
                </div>
                <div id="swatches"></div>
            </div>
            <div class="divider"></div>
            <div id="toolOptions">
                <h4>Tool Options</h4>
                <label for="strokeWidth">Stroke:</label>
                <input type="range" id="strokeWidth" min="1" max="50" value="5" aria-label="Stroke Width">
                <label for="opacity">Opacity:</label>
                <input type="range" id="opacity" min="0" max="1" step="0.1" value="1" aria-label="Opacity">
                <label for="fill">Fill:</label>
                <input type="checkbox" id="fill" aria-label="Fill Toggle">
                <label for="strokeStyle">Style:</label>
                <select id="strokeStyle" aria-label="Stroke Style">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
            </div>
            <div class="divider"></div>
            <div id="exportOptions">
                <input id="filenameInput" placeholder="project-name-date" aria-label="Export Filename">
                <button class="export-btn tooltip" id="exportSvg" title="Export as SVG" aria-label="Export as SVG">
                    <svg viewBox="0 0 24 24"><path d="M19 3H5v18l7-3 7 3V3z"/></svg>
                    SVG
                </button>
                <button class="export-btn tooltip" id="exportPng" title="Export as PNG" aria-label="Export as PNG">
                    <svg viewBox="0 0 24 24"><path d="M19 3H5v18l7-3 7 3V3z"/></svg>
                    PNG
                </button>
                <button class="export-btn tooltip" id="exportJpeg" title="Export as JPEG" aria-label="Export as JPEG">
                    <svg viewBox="0 0 24 24"><path d="M19 3H5v18l7-3 7 3V3z"/></svg>
                    JPEG
                </button>
            </div>
        </div>
        <div id="canvasContainer">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div id="dropZone">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-upload-cloud">
                    <path d="M8 17H4a2 2 0 0 1-2-2v-3h1v3a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3h1v3a2 2 0 0 1-2 2H16"/>
                    <polyline points="10 9 7 12 4 9"/>
                    <line x1="10" x2="10" y1="3" y2="12"/>
                    <path d="M20 12v-1a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v1"/>
                </svg>
                <span style="margin-left: 8px;">Drag and drop image here or <button id="browseBtn" style="background: none; border: none; color: var(--glow-color); cursor: pointer; padding: 0; font-size: inherit;">browse</button></span>
            </div>
        </div>
        <div id="footer">
            <a href="#" aria-label="About Doppleit">About</a> |
            <a href="#" aria-label="Support">Support</a> |
            &copy; 2025 Doppleit Creations | <a href="#">Privacy Policy</a> | <a href="#">Terms of Service</a>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorCanvas = document.getElementById('colorCanvas');
        const colorCtx = colorCanvas.getContext('2d');
        const lightnessSlider = document.getElementById('lightnessSlider');
        const lightnessCtx = lightnessSlider.getContext('2d');
        const hexInput = document.getElementById('hexInput');
        const hslInput = document.getElementById('hslInput');
        const rgbInput = document.getElementById('rgbInput');
        const swatchesDiv = document.getElementById('swatches');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const opacityInput = document.getElementById('opacity');
        const fillInput = document.getElementById('fill');
        const strokeStyleInput = document.getElementById('strokeStyle');
        const filenameInput = document.getElementById('filenameInput');
        const exportSvgBtn = document.getElementById('exportSvg');
        const exportPngBtn = document.getElementById('exportPng');
        const exportJpegBtn = document.getElementById('exportJpeg');
        const importBtn = document.getElementById('importBtn');
        const importImageInput = document.getElementById('importImage');
        const dropZone = document.getElementById('dropZone');
        const browseBtn = document.getElementById('browseBtn');
        const toolButtons = document.querySelectorAll('.tool-btn');

        let currentTool = 'pen';
        let drawing = false;
        let paths = [];
        let currentPath = null;
        let currentColor = '#e37800';
        let currentLightness = 50;
        let swatchHistory = JSON.parse(localStorage.getItem('swatches')) || ['#e37800', '#ffb340', '#ffffff', '#000000', '#cccccc', '#666666'];
        let backgroundImage = null;
        let undoStack = [];
        let redoStack = [];

        // Initialize Canvas and Color Picker
        function initialize() {
            const today = new Date().toISOString().slice(0, 10);
            filenameInput.value = `doppleit-vector-${today}`;
            drawColorWheel();
            drawLightnessSlider();
            updateSwatches();
            redrawCanvas();
        }

        // Tool Switching
        toolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                toolButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                canvas.style.cursor = currentTool === 'pen' ? 'crosshair' : 'default';
            });
        });

        // Color Picker Logic
        function drawColorWheel() {
            const width = colorCanvas.width;
            const height = colorCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2;

            colorCtx.clearRect(0, 0, width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distanceSquared = dx * dx + dy * dy;
                    if (distanceSquared <= radius * radius) {
                        const angle = Math.atan2(dy, dx);
                        const saturation = Math.sqrt(distanceSquared) / radius;
                        const hue = angle * (180 / Math.PI) + 180;
                        const lightness = currentLightness / 100;
                        colorCtx.fillStyle = `hsl(${hue}, ${saturation * 100}%, ${lightness * 100}%)`;
                        colorCtx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        function drawLightnessSlider() {
            const width = lightnessSlider.width;
            const height = lightnessSlider.height;
            const gradient = lightnessCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.5, `hsl(0, 0%, ${currentLightness}%)`);
            gradient.addColorStop(1, 'black');
            lightnessCtx.fillStyle = gradient;
            lightnessCtx.fillRect(0, 0, width, height);
        }

        function updateColor(hue, saturation, lightness) {
            currentColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            hexInput.value = hslToHex(hue, saturation, lightness);
            hslInput.value = `${Math.round(hue)}, ${Math.round(saturation)}%, ${Math.round(lightness)}%`;
            rgbInput.value = hslToRgb(hue, saturation, lightness).join(', ');

            swatchHistory = swatchHistory.filter(color => color !== currentColor);
            swatchHistory.unshift(currentColor);
            if (swatchHistory.length > 6) swatchHistory.pop();
            localStorage.setItem('swatches', JSON.stringify(swatchHistory));
            updateSwatches();

            drawColorWheel();
            drawLightnessSlider();
        }

        function updateSwatches() {
            swatchesDiv.innerHTML = '';
            swatchHistory.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'swatch';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => {
                    const [h, s, l] = rgbToHsl(...hexToRgb(color));
                    currentLightness = l;
                    updateColor(h, s, l);
                });
                swatchesDiv.appendChild(swatch);
            });
        }

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                h /= 360;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function hslToHex(h, s, l) {
            const [r, g, b] = hslToRgb(h, s, l);
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
        }

        let isDraggingColor = false;
        let isDraggingLightness = false;

        colorCanvas.addEventListener('mousedown', (e) => {
            isDraggingColor = true;
            handleColorPicker(e);
        });

        colorCanvas.addEventListener('mousemove', (e) => {
            if (isDraggingColor) handleColorPicker(e);
        });

        colorCanvas.addEventListener('mouseup', () => {
            isDraggingColor = false;
        });

        lightnessSlider.addEventListener('mousedown', (e) => {
            isDraggingLightness = true;
            handleLightnessSlider(e);
        });

        lightnessSlider.addEventListener('mousemove', (e) => {
            if (isDraggingLightness) handleLightnessSlider(e);
        });

        lightnessSlider.addEventListener('mouseup', () => {
            isDraggingLightness = false;
        });

        function handleColorPicker(e) {
            const rect = colorCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const radius = Math.min(rect.width, rect.height) / 2;
            const dx = x - centerX;
            const dy = y - centerY;
            const distanceSquared = dx * dx + dy * dy;

            if (distanceSquared <= radius * radius) {
                const angle = Math.atan2(dy, dx);
                const saturation = Math.sqrt(distanceSquared) / radius * 100;
                const hue = angle * (180 / Math.PI) + 180;
                updateColor(hue, saturation, currentLightness);
            }
        }

        function handleLightnessSlider(e) {
            const rect = lightnessSlider.getBoundingClientRect();
            let y = e.clientY - rect.top;
            currentLightness = Math.max(0, Math.min(100, (1 - y / rect.height) * 100));
            const [h, s] = hslInput.value.split(', ').map(v => parseFloat(v));
            updateColor(h, s, currentLightness);
        }

        hexInput.addEventListener('input', () => {
            const hex = hexInput.value;
            if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
                const [r, g, b] = hexToRgb(hex);
                const [h, s, l] = rgbToHsl(r, g, b);
                currentLightness = l;
                updateColor(h, s, l);
            }
        });

        hslInput.addEventListener('input', () => {
            const hslValues = hslInput.value.split(',').map(v => parseFloat(v.trim()));
            if (hslValues.length === 3 && hslValues.every(v => !isNaN(v))) {
                const [h, s, l] = hslValues;
                currentLightness = l;
                updateColor(h, s, l);
            }
        });

        rgbInput.addEventListener('input', () => {
            const rgbValues = rgbInput.value.split(',').map(v => parseInt(v.trim()));
            if (rgbValues.length === 3 && rgbValues.every(v => !isNaN(v))) {
                const [h, s, l] = rgbToHsl(...rgbValues);
                currentLightness = l;
                updateColor(h, s, l);
            }
        });

        // Drawing Logic
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }

            paths.forEach(path => {
                ctx.beginPath();
                if (path.type === 'pen') {
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    path.points.forEach(point => {
                        ctx.lineTo(point.x, point.y);
                    });
                } else if (path.type === 'shape') {
                    ctx.rect(path.startX, path.startY, path.endX - path.startX, path.endY - path.startY);
                }

                if (path.fill) {
                    ctx.fillStyle = path.color;
                    ctx.globalAlpha = path.opacity;
                    ctx.fill();
                }
                ctx.strokeStyle = path.color;
                ctx.lineWidth = path.strokeWidth;
                ctx.globalAlpha = path.opacity;
                if (path.strokeStyle === 'dashed') {
                    ctx.setLineDash([10, 10]);
                } else if (path.strokeStyle === 'dotted') {
                    ctx.setLineDash([2, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            currentPath = {
                type: currentTool,
                points: currentTool === 'pen' ? [{ x, y }] : null,
                startX: x,
                startY: y,
                endX: x,
                endY: y,
                color: currentColor,
                strokeWidth: parseInt(strokeWidthInput.value),
                opacity: parseFloat(opacityInput.value),
                fill: fillInput.checked,
                strokeStyle: strokeStyleInput.value
            };

            if (currentTool === 'pen') {
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            undoStack.push(JSON.parse(JSON.stringify(paths)));
            redoStack = [];
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'pen') {
                currentPath.points.push({ x, y });
                ctx.lineTo(x, y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = parseInt(strokeWidthInput.value);
                ctx.globalAlpha = parseFloat(opacityInput.value);
                if (strokeStyleInput.value === 'dashed') {
                    ctx.setLineDash([10, 10]);
                } else if (strokeStyleInput.value === 'dotted') {
                    ctx.setLineDash([2, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            } else if (currentTool === 'shape') {
                currentPath.endX = x;
                currentPath.endY = y;
                redrawCanvas();
                ctx.beginPath();
                ctx.rect(currentPath.startX, currentPath.startY, x - currentPath.startX, y - currentPath.startY);
                if (fillInput.checked) {
                    ctx.fillStyle = currentColor;
                    ctx.globalAlpha = parseFloat(opacityInput.value);
                    ctx.fill();
                }
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = parseInt(strokeWidthInput.value);
                ctx.globalAlpha = parseFloat(opacityInput.value);
                if (strokeStyleInput.value === 'dashed') {
                    ctx.setLineDash([10, 10]);
                } else if (strokeStyleInput.value === 'dotted') {
                    ctx.setLineDash([2, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (drawing && currentPath) {
                paths.push(currentPath);
                currentPath = null;
                redrawCanvas();
            }
            drawing = false;
        });

        canvas.addEventListener('mouseout', () => {
            if (drawing) {
                paths.push(currentPath);
                currentPath = null;
                redrawCanvas();
                drawing = false;
            }
        });

        // Import Logic
        function handleImportImage(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    backgroundImage = new Image();
                    backgroundImage.src = event.target.result;
                    backgroundImage.onload = () => {
                        redrawCanvas();
                        dropZone.classList.remove('active');
                    };
                };
                reader.readAsDataURL(file);
            }
        }

        importBtn.addEventListener('click', () => importImageInput.click());
        importImageInput.addEventListener('change', handleImportImage);
        browseBtn.addEventListener('click', () => importImageInput.click());

        // Drag and Drop Logic
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    backgroundImage = new Image();
                    backgroundImage.src = event.target.result;
                    backgroundImage.onload = () => {
                        redrawCanvas();
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Export Logic
        function exportCanvas(format) {
            const filename = filenameInput.value || 'doppleit-vector';
            let dataUrl;

            if (format === 'svg') {
                let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">`;
                if (backgroundImage) {
                    svgContent += `<image x="0" y="0" width="${canvas.width}" height="${canvas.height}" href="${backgroundImage.src}" />`;
                }
                paths.forEach(path => {
                    if (path.type === 'pen') {
                        const d = path.points.map((p, i) => i === 0 ? `M${p.x},${p.y}` : `L${p.x},${p.y}`).join(' ');
                        svgContent += `<path d="${d}" fill="${path.fill ? path.color : 'none'}" stroke="${path.color}" stroke-width="${path.strokeWidth}" opacity="${path.opacity}" stroke-dasharray="${path.strokeStyle === 'dashed' ? '10,10' : path.strokeStyle === 'dotted' ? '2,5' : ''}"/>`;
                    } else if (path.type === 'shape') {
                        svgContent += `<rect x="${path.startX}" y="${path.startY}" width="${path.endX - path.startX}" height="${path.endY - path.startY}" fill="${path.fill ? path.color : 'none'}" stroke="${path.color}" stroke-width="${path.strokeWidth}" opacity="${path.opacity}" stroke-dasharray="${path.strokeStyle === 'dashed' ? '10,10' : path.strokeStyle === 'dotted' ? '2,5' : ''}"/>`;
                    }
                });
                svgContent += `</svg>`;
                dataUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(svgContent);
            } else {
                redrawCanvas(); // Ensure canvas is up-to-date
                dataUrl = format === 'png' ? canvas.toDataURL('image/png') : canvas.toDataURL('image/jpeg', 0.9);
            }

            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `${filename}.${format}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        exportSvgBtn.addEventListener('click', () => exportCanvas('svg'));
        exportPngBtn.addEventListener('click', () => exportCanvas('png'));
        exportJpegBtn.addEventListener('click', () => exportCanvas('jpeg'));

        // Initialize
        initialize();
    </script>
</body>
</html>