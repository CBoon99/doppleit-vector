<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cindara Vector â€“ Final Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>
    <style>
        :root {
            --current-color: #ff8000;
        }
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #1a1a1a 0%, #2a2a40 100%);
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #toolbar {
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        .toolbar-group {
            display: flex;
            gap: 12px;
            align-items: center;
            flex: 0 0 auto;
        }
        .toolbar-group:not(:last-child) {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding-right: 24px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.25s ease-in-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        button.active {
            background: rgba(255, 255, 255, 0.35);
            font-weight: 700;
            box-shadow: 0 0 8px #ffffffaa, 0 0 16px #ffbf00aa;
            transform: scale(1.05);
            border: 2px solid #ffbf00;
        }
        #colorPalette {
            position: relative;
            display: inline-block;
        }
        #colorToggle {
            padding: 10px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #colorPanel {
            display: none;
            position: absolute;
            top: 50px;
            left: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 10;
            transition: opacity 0.2s ease;
        }
        #colorPanel.open {
            display: block;
            opacity: 1;
        }
        #colorSpectrum {
            width: 200px;
            height: 150px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }
        #lightnessSlider, #hexInput, #strokeWidth {
            width: 200px;
            margin: 10px 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: none;
            color: #fff;
            font-size: 12px;
            padding: 8px;
            transition: box-shadow 0.25s ease-in-out;
        }
        #lightnessSlider:hover, #hexInput:hover, #strokeWidth:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #lightnessSlider, #strokeWidth {
            appearance: none;
        }
        #lightnessSlider::-webkit-slider-thumb, #strokeWidth::-webkit-slider-thumb {
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--current-color);
            cursor: pointer;
        }
        #swatches {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .swatch {
            width: 24px;
            height: 24px;
            border-radius: 12px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .swatch:hover, .swatch.selected {
            border-color: #fff;
            transform: scale(1.1);
        }
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        #canvas-frame {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        #myCanvas {
            background: #fff;
            border-radius: 8px;
            max-width: 100%;
            max-height: 100%;
        }
        #svgPreview {
            position: absolute;
            pointer-events: none;
            max-width: 100%;
            max-height: 100%;
        }
        @media (max-width: 768px) {
            #toolbar {
                padding: 12px;
                gap: 16px;
            }
            .toolbar-group:not(:last-child) {
                padding-right: 16px;
            }
            button {
                padding: 10px 14px;
                font-size: 13px;
            }
            #colorPanel {
                width: 100%;
                left: 0;
                top: 40px;
            }
            #colorSpectrum, #lightnessSlider, #hexInput, #strokeWidth {
                width: 100%;
            }
            #canvas-container {
                padding: 10px;
            }
            #canvas-frame {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <div class="toolbar-group">
            <button onclick="setTool('pen')" id="penBtn" class="active" aria-label="Pen Tool">Pen</button>
            <button onclick="setTool('eraser')" id="eraserBtn" aria-label="Eraser Tool">Eraser</button>
            <button onclick="setTool('rectangle')" id="rectBtn" aria-label="Rectangle Tool">Rectangle</button>
        </div>
        <div class="toolbar-group">
            <div id="colorPalette">
                <button id="colorToggle" style="background: #ff8000;" onclick="toggleColorPanel()" aria-label="Toggle Color Panel">ðŸŽ¨</button>
                <div id="colorPanel">
                    <canvas id="colorSpectrum" width="200" height="150" aria-label="HSL Color Spectrum"></canvas>
                    <input type="range" id="lightnessSlider" min="0" max="100" value="50" aria-label="Lightness Slider">
                    <input type="text" id="hexInput" value="#FF8000" aria-label="HEX Color Code">
                    <div id="swatches" aria-label="Recent Color Swatches"></div>
                </div>
            </div>
            <input type="range" id="strokeWidth" min="1" max="20" value="3" onchange="setStrokeWidth(this.value)" aria-label="Stroke Width">
        </div>
        <div class="toolbar-group">
            <button onclick="zoomIn()" aria-label="Zoom In">Zoom In</button>
            <button onclick="zoomOut()" aria-label="Zoom Out">Zoom Out</button>
        </div>
        <div class="toolbar-group">
            <input type="file" id="imageUpload" accept="image/png,image/jpeg" onchange="uploadImage(event)" aria-label="Upload Image">
            <button onclick="toggleImageLock()" id="lockBtn" aria-label="Lock Image">Lock Image</button>
            <button onclick="vectorizeImage()" aria-label="Vectorize Image">Vectorize</button>
        </div>
        <div class="toolbar-group">
            <button onclick="exportCanvas('svg')" aria-label="Export as SVG">Export SVG</button>
            <button onclick="exportCanvas('png')" aria-label="Export as PNG">Export PNG</button>
            <button onclick="exportCanvas('json')" aria-label="Export as JSON">Export JSON</button>
        </div>
    </div>
    <div id="canvas-container">
        <div id="canvas-frame">
            <canvas id="myCanvas" width="300" height="200"></canvas>
            <svg id="svgPreview"></svg>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const svgPreview = document.getElementById('svgPreview');
        let tool = 'pen';
        let isDrawing = false;
        let zoomLevel = 1;
        let startX, startY;
        let paths = [];
        let currentPath = null;
        let uploadedImage = null;
        let isImageLocked = false;
        let currentColor = { h: 0, s: 100, l: 50 };
        const recentSwatches = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF8000'];

        // Initialize canvas
        function initializeCanvas() {
            const container = document.getElementById('canvas-container');
            const minWidth = 300;
            const minHeight = 200;
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.8;
            canvas.width = Math.min(Math.max(container.clientWidth * 0.8, minWidth), maxWidth);
            canvas.height = Math.min(Math.max(container.clientHeight * 0.8, minHeight), maxHeight);
            svgPreview.style.width = `${canvas.width}px`;
            svgPreview.style.height = `${canvas.height}px`;

            window.addEventListener('resize', () => {
                canvas.width = Math.min(Math.max(container.clientWidth * 0.8, minWidth), maxWidth);
                canvas.height = Math.min(Math.max(container.clientHeight * 0.8, minHeight), maxHeight);
                svgPreview.style.width = `${canvas.width}px`;
                svgPreview.style.height = `${canvas.height}px`;
                redrawCanvas();
            });

            ctx.lineWidth = 3;
            ctx.strokeStyle = '#FF8000';
            ctx.fillStyle = '#FF8000';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Initialize color palette
            initializeColorPalette();
        }

        // Initialize color palette
        function initializeColorPalette() {
            const spectrum = document.getElementById('colorSpectrum');
            const spectrumCtx = spectrum.getContext('2d');
            const lightnessSlider = document.getElementById('lightnessSlider');
            const hexInput = document.getElementById('hexInput');
            const swatchesDiv = document.getElementById('swatches');
            let markerX = (currentColor.h / 360) * spectrum.width;
            let markerY = (1 - currentColor.s / 100) * spectrum.height;

            // Render HSL spectrum
            function renderSpectrum() {
                spectrumCtx.clearRect(0, 0, spectrum.width, spectrum.height);
                for (let x = 0; x < spectrum.width; x++) {
                    for (let y = 0; y < spectrum.height; y++) {
                        const h = (x / spectrum.width) * 360;
                        const s = (1 - y / spectrum.height) * 100;
                        spectrumCtx.fillStyle = `hsl(${h}, ${s}%, 50%)`;
                        spectrumCtx.fillRect(x, y, 1, 1);
                    }
                }
                // Draw marker
                spectrumCtx.beginPath();
                spectrumCtx.arc(markerX, markerY, 5, 0, Math.PI * 2);
                spectrumCtx.strokeStyle = '#fff';
                spectrumCtx.lineWidth = 2;
                spectrumCtx.stroke();
            }
            renderSpectrum();

            // Update swatches
            function updateSwatches() {
                swatchesDiv.innerHTML = '';
                recentSwatches.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'swatch';
                    swatch.style.backgroundColor = color;
                    swatch.onclick = () => {
                        setColor(color);
                        swatchesDiv.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
                        swatch.classList.add('selected');
                    };
                    swatchesDiv.appendChild(swatch);
                });
            }

            // Spectrum click handler
            spectrum.addEventListener('mousedown', e => {
                const rect = spectrum.getBoundingClientRect();
                markerX = e.clientX - rect.left;
                markerY = e.clientY - rect.top;
                currentColor.h = (markerX / rect.width) * 360;
                currentColor.s = (1 - markerY / rect.height) * 100;
                updateColor();
                renderSpectrum();
            });

            // Lightness slider
            lightnessSlider.addEventListener('input', () => {
                currentColor.l = lightnessSlider.value;
                updateColor();
            });

            // Hex input
            hexInput.addEventListener('input', () => {
                if (/^#[0-9A-F]{6}$/i.test(hexInput.value)) {
                    const rgb = hexToRgb(hexInput.value);
                    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                    currentColor = hsl;
                    markerX = (hsl.h / 360) * spectrum.width;
                    markerY = (1 - hsl.s / 100) * spectrum.height;
                    lightnessSlider.value = hsl.l;
                    updateColor();
                    renderSpectrum();
                }
            });

            // Update color
            function updateColor() {
                const rgb = hslToRgb(currentColor.h, currentColor.s, currentColor.l);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                ctx.strokeStyle = hex;
                ctx.fillStyle = hex;
                if (currentPath) currentPath.color = hex;
                hexInput.value = hex;
                document.getElementById('colorToggle').style.background = hex;
                document.documentElement.style.setProperty('--current-color', hex);
                if (!recentSwatches.includes(hex)) {
                    recentSwatches.unshift(hex);
                    if (recentSwatches.length > 10) recentSwatches.pop();
                    updateSwatches();
                }
            }

            // Color conversion helpers
            function hslToRgb(h, s, l) {
                s /= 100;
                l /= 100;
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;
                if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
                return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
            }

            function rgbToHex(r, g, b) {
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
            }

            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            updateSwatches();
        }

        // Toggle color panel
        function toggleColorPanel() {
            const panel = document.getElementById('colorPanel');
            panel.classList.toggle('open');
        }

        // Set drawing tool
        function setTool(newTool) {
            tool = newTool;
            ctx.globalCompositeOperation = newTool === 'eraser' ? 'destination-out' : 'source-over';
            ['penBtn', 'eraserBtn', 'rectBtn'].forEach(id => document.getElementById(id).classList.remove('active'));
            document.getElementById(`${newTool === 'rectangle' ? 'rect' : newTool}Btn`).classList.add('active');
        }

        // Set stroke width
        function setStrokeWidth(width) {
            ctx.lineWidth = width;
            if (currentPath) currentPath.width = width;
        }

        // Toggle image lock
        function toggleImageLock() {
            isImageLocked = !isImageLocked;
            document.getElementById('lockBtn').classList.toggle('active', isImageLocked);
            redrawCanvas();
        }

        // Start drawing
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) / zoomLevel;
            startY = (e.clientY - rect.top) / zoomLevel;

            currentPath = {
                type: tool,
                points: [{ x: startX, y: startY }],
                color: ctx.strokeStyle,
                width: ctx.lineWidth
            };
            ctx.beginPath();
        }

        // Draw on canvas
        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;

            if (tool === 'pen' || tool === 'eraser') {
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
                currentPath.points.push({ x, y });
            } else if (tool === 'rectangle') {
                redrawCanvas();
                ctx.strokeRect(startX, startY, x - startX, y - startY);
                currentPath.points = [{ x: startX, y: startY }, { x, y }];
            }
        }

        // Stop drawing
        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                ctx.beginPath();
                if (currentPath) {
                    paths.push(currentPath);
                    currentPath = null;
                    redrawCanvas();
                }
            }
        }

        // Zoom in
        function zoomIn() {
            zoomLevel *= 1.1;
            redrawCanvas();
        }

        // Zoom out
        function zoomOut() {
            zoomLevel /= 1.1;
            redrawCanvas();
        }

        // Redraw canvas
        function redrawCanvas() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(zoomLevel, zoomLevel);

            // Draw locked image
            if (uploadedImage && isImageLocked) {
                ctx.drawImage(uploadedImage, 0, 0, canvas.width / zoomLevel, canvas.height / zoomLevel);
            }

            // Draw paths
            paths.forEach(path => {
                ctx.beginPath();
                ctx.strokeStyle = path.color;
                ctx.lineWidth = path.width;
                ctx.globalCompositeOperation = path.type === 'eraser' ? 'destination-out' : 'source-over';

                if (path.type === 'pen' || path.type === 'eraser') {
                    path.points.forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                } else if (path.type === 'rectangle') {
                    const [start, end] = path.points;
                    ctx.strokeRect(start.x, start.y, end.x - start.x, end.y - start.y);
                } else if (path.type === 'vector' && path.svgPath) {
                    ctx.stroke(new Path2D(path.svgPath));
                }
            });

            // Draw unlocked image
            if (uploadedImage && !isImageLocked) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(uploadedImage, 0, 0, canvas.width / zoomLevel, canvas.height / zoomLevel);
            }

            ctx.restore();

            // Update SVG preview
            updateSvgPreview();
        }

        // Update SVG preview
        function updateSvgPreview() {
            svgPreview.innerHTML = '';
            paths.forEach(path => {
                if (path.type === 'vector' && path.svgPath) {
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path.svgPath);
                    pathEl.setAttribute('stroke', path.color);
                    pathEl.setAttribute('stroke-width', path.width / zoomLevel);
                    pathEl.setAttribute('fill', 'none');
                    pathEl.setAttribute('transform', `scale(${1 / zoomLevel})`);
                    svgPreview.appendChild(pathEl);
                }
            });
            svgPreview.setAttribute('width', canvas.width / zoomLevel);
            svgPreview.setAttribute('height', canvas.height / zoomLevel);
        }

        // Upload image
        function uploadImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                uploadedImage = new Image();
                uploadedImage.src = reader.result;
                uploadedImage.onload = () => {
                    redrawCanvas();
                };
            };
            reader.readAsDataURL(file);
        }

        // Vectorize image
        function vectorizeImage() {
            if (!uploadedImage) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);

            ImageTracer.imageToSVG(
                tempCanvas.toDataURL(),
                svgStr => {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgStr, 'image/svg+xml');
                    const pathsElements = svgDoc.querySelectorAll('path');
                    pathsElements.forEach(pathEl => {
                        const d = pathEl.getAttribute('d');
                        const fill = pathEl.getAttribute('fill') || ctx.strokeStyle;
                        paths.push({
                            type: 'vector',
                            svgPath: d,
                            color: fill,
                            width: ctx.lineWidth
                        });
                    });
                    redrawCanvas();
                },
                'default'
            );
        }

        // Export canvas
        function exportCanvas(format) {
            if (format === 'png') {
                const dataURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'cindara_vector.png';
                link.click();
            } else if (format === 'svg') {
                let svgContent = `<svg width="${canvas.width}" height="${canvas.height}" xmlns="http://www.w3.org/2000/svg">`;
                paths.forEach(path => {
                    if (path.type === 'pen' || path.type === 'eraser') {
                        svgContent += `<polyline points="${path.points.map(p => `${p.x},${p.y}`).join(' ')}" stroke="${path.color}" stroke-width="${path.width}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
                    } else if (path.type === 'rectangle') {
                        const [start, end] = path.points;
                        svgContent += `<rect x="${start.x}" y="${start.y}" width="${end.x - start.x}" height="${end.y - start.y}" stroke="${path.color}" stroke-width="${path.width}" fill="none"/>`;
                    } else if (path.type === 'vector' && path.svgPath) {
                        svgContent += `<path d="${path.svgPath}" stroke="${path.color}" stroke-width="${path.width}" fill="none"/>`;
                    }
                });
                svgContent += '</svg>';
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'cindara_vector.svg';
                link.click();
                URL.revokeObjectURL(url);
            } else if (format === 'json') {
                const json = JSON.stringify(paths.map(path => ({
                    type: path.type,
                    points: path.points,
                    svgPath: path.svgPath,
                    color: path.color,
                    width: path.width
                })), null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'cindara_vector.json';
                link.click();
                URL.revokeObjectURL(url);
            }
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch events
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            startDrawing(e.touches[0]);
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            draw(e.touches[0]);
        });
        canvas.addEventListener('touchend', stopDrawing);

        // Initialize
        window.addEventListener('load', initializeCanvas);
    </script>
</body>
</html>