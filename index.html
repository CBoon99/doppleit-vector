<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self'; font-src 'self' https://fonts.gstatic.com; script-src 'self' 'nonce-doppleit'; style-src 'self' 'nonce-doppleit' https://fonts.googleapis.com; img-src 'self' data: blob:; connect-src 'self'">
    <meta name="description" content="Create and edit vector graphics with Doppleit Vector v2 Pro. Fast, in-browser processing.">
    <meta name="keywords" content="vector editor, SVG converter, Doppleit Vector">
    <title>Doppleit Vector v2 Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90' font-family='Inter' fill='%23e37800'%3ED%3C/text%3E%3C/svg%3E" />
    <style nonce="doppleit">
        :root {
            --primary-color: #e37800;
            --glow-color: #ffbf40;
            --gradient: linear-gradient(90deg, #e37800, #ffbf40);
            --shadow-glow: 0 0 15px rgba(255, 191, 64, 0.6);
            --error-color: #ff5555;
            --bg-color: #1a1a1a;
            --text-color: #fff;
            --panel-bg: #222;
            --high-contrast-bg: #000;
            --high-contrast-text: #fff;
        }

        [data-theme="light"] {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --panel-bg: #ddd;
            --high-contrast-bg: #fff;
            --high-contrast-text: #000;
        }

        [data-high-contrast="true"] {
            --bg-color: var(--high-contrast-bg);
            --text-color: var(--high-contrast-text);
            --panel-bg: var(--high-contrast-bg);
            --primary-color: #ff0;
            --glow-color: #ff0;
        }

        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        #app {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
        }

        #header h1 {
            margin: 0;
            font-size: 2.5rem;
            text-shadow: var(--shadow-glow);
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 191, 64, 0.4); }
            to { text-shadow: 0 0 20px rgba(255, 191, 64, 0.8); }
        }

        #tagline {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 20px;
            position: relative;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); text-shadow: 0 0 5px var(--glow-color); }
            20% { transform: translate(-1px, 1px); text-shadow: -1px 1px #f00, 1px -1px #0ff; }
            40% { transform: translate(1px, -1px); text-shadow: 1px -1px #f00, -1px 1px #0ff; }
            60% { transform: translate(0); text-shadow: 0 0 5px var(--glow-color); }
            100% { transform: translate(0); text-shadow: 0 0 5px var(--glow-color); }
        }

        section {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-glow);
            transition: background-color 0.3s ease;
        }

        .hidden {
            display: none !important;
        }

        #upload-area {
            border: 2px dashed #888;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            transition: border-color 0.3s ease;
        }

        #upload-area.invalid {
            border-color: var(--error-color);
        }

        #error-message {
            color: var(--error-color);
            margin-top: 10px;
        }

        #confirmation-message {
            color: #0f0;
            margin-top: 10px;
        }

        #loading-message {
            margin-top: 10px;
            color: var(--glow-color);
        }

        #progress-bar {
            width: 100%;
            height: 5px;
            background: #444;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        #progress-fill {
            height: 100%;
            background: var(--gradient);
            width: 0;
            transition: width 0.5s ease;
        }

        #thumbnail-preview {
            max-width: 200px;
            margin-top: 10px;
            border-radius: 4px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-size: 14px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #444;
            border-radius: 4px;
            outline: none;
            transition: background 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--gradient);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-glow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--gradient);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-glow);
        }

        input[type="text"],
        input[type="color"],
        select {
            padding: 8px;
            border: 1px solid #888;
            border-radius: 4px;
            background: #333;
            color: var(--text-color);
            transition: border-color 0.3s ease;
        }

        input:focus,
        select:focus {
            border-color: var(--glow-color);
            outline: none;
        }

        .button {
            padding: 10px 20px;
            background: var(--gradient);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.active {
            background: #fff;
            color: #000;
        }

        #drawing-tools {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        #canvas-section {
            position: relative;
            display: inline-block;
        }

        #drawing-canvas,
        #color-wheel {
            border: 1px solid #888;
            border-radius: 4px;
        }

        #grid {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #swatches {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .swatch:hover {
            transform: scale(1.2);
        }

        #preview-window {
            margin-top: 20px;
            border: 1px solid #888;
            padding: 10px;
            border-radius: 4px;
            background: var(--bg-color);
        }

        #svg-output {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            background: #333;
            padding: 10px;
            border-radius: 4px;
        }

        #debug-panel,
        #help-modal {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-glow);
            max-width: 400px;
            z-index: 1000;
        }

        #help-modal {
            max-width: 600px;
            right: auto;
            left: 50%;
            transform: translateX(-50%);
        }

        #tooltip {
            position: fixed;
            background: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }

        #text-input {
            position: absolute;
            background: #333;
            color: var(--text-color);
            border: 1px solid var(--glow-color);
            border-radius: 4px;
            padding: 5px;
            z-index: 100;
        }

        @media (max-width: 768px) {
            #app {
                padding: 10px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            #drawing-canvas,
            #color-wheel {
                width: 100% !important;
                height: auto !important;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .button,
            .swatch,
            #header h1,
            #tagline {
                animation: none;
                transition: none;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header id="header">
            <h1>Doppleit Vector v2 Pro</h1>
            <p id="tagline">Create and edit vector graphics right in your browser.</p>
        </header>

        <section id="upload-section">
            <div id="upload-area">
                <p>Drag and drop your image here (JPG, PNG, SVG)</p>
                <button id="browse-button" class="button">Browse Files</button>
                <input type="file" id="file-upload" accept="image/jpeg,image/png,image/svg+xml" class="hidden" />
                <p id="upload-instructions" class="hidden"></p>
                <div id="progress-bar" class="hidden">
                    <div id="progress-fill"></div>
                </div>
                <p id="loading-message" class="hidden">Processing...</p>
                <p id="error-message" class="hidden"></p>
                <p id="confirmation-message" class="hidden">File processed successfully!</p>
                <img id="thumbnail-preview" class="hidden" alt="Uploaded image thumbnail" />
            </div>
        </section>

        <section id="controls-section">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="color-wheel">Color Picker</label>
                    <canvas id="color-wheel" width="100" height="100"></canvas>
                </div>
                <div class="control-group">
                    <label for="lightness-slider">Lightness: <span id="lightness-value">50%</span></label>
                    <input type="range" id="lightness-slider" min="0" max="100" value="50" aria-valuenow="50" aria-label="Lightness" />
                </div>
                <div class="control-group">
                    <label for="opacity-slider">Opacity: <span id="opacity-value">100%</span></label>
                    <input type="range" id="opacity-slider" min="0" max="1" step="0.01" value="1" aria-valuenow="1" aria-label="Opacity" />
                </div>
                <div class="control-group">
                    <label for="stroke-width-slider">Stroke Width: <span id="stroke-width-value">1px</span></label>
                    <input type="range" id="stroke-width-slider" min="1" max="20" value="1" aria-valuenow="1" aria-label="Stroke Width" />
                </div>
                <div class="control-group">
                    <label for="stroke-style">Stroke Style</label>
                    <select id="stroke-style">
                        <option value="solid">Solid</option>
                        <option value="dashed">Dashed</option>
                        <option value="dotted">Dotted</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="hex-input">HEX</label>
                    <input type="text" id="hex-input" maxlength="7" value="#e37800" aria-label="HEX color input" />
                </div>
                <div class="control-group">
                    <label for="rgb-input">RGB</label>
                    <input type="text" id="rgb-input" value="227,120,0" aria-label="RGB color input" />
                </div>
                <div class="control-group">
                    <label for="hsl-input">HSL</label>
                    <input type="text" id="hsl-input" value="32,100%,44%" aria-label="HSL color input" />

</div>
                <div class="control-group">
                    <label for="native-picker">System Color Picker</label>
                    <input type="color" id="native-picker" value="#e37800" aria-label="System color picker" />
                    <button id="system-picker" class="button">Open System Picker</button>
                </div>
                <div class="control-group">
                    <label for="fill-toggle">Fill Shape</label>
                    <input type="checkbox" id="fill-toggle" checked aria-label="Toggle fill" />
                </div>
            </div>
            <div id="swatches" style="margin-top: 20px;"></div>
        </section>

        <section id="drawing-tools">
            <nav>
                <button id="pen-tool" class="button active" title="Pen Tool (1)">Pen</button>
                <button id="rect-tool" class="button" title="Rectangle Tool (2)">Rectangle</button>
                <button id="circle-tool" class="button" title="Circle Tool (3)">Circle</button>
                <button id="text-tool" class="button" title="Text Tool (4)">Text</button>
                <button id="select-tool" class="button" title="Select Tool (S)">Select</button>
                <button id="eyedropper-tool" class="button" title="Eyedropper">Eyedropper</button>
                <button id="undo" class="button" title="Undo (Ctrl+Z)">Undo</button>
                <button id="redo" class="button" title="Redo (Ctrl+Y)">Redo</button>
                <button id="delete" class="button" title="Delete Selected">Delete</button>
                <button id="clear-canvas" class="button" title="Clear Canvas">Clear</button>
            </nav>
        </section>

        <section id="canvas-section" class="hidden">
            <div style="position: relative;">
                <svg id="grid" class="hidden"></svg>
                <canvas id="drawing-canvas" width="800" height="600"></canvas>
                <input type="text" id="text-input" class="hidden" placeholder="Enter text" />
            </div>
            <div style="margin-top: 10px;">
                <label for="snap-grid">Snap to Grid</label>
                <input type="checkbox" id="snap-grid" checked />
            </div>
        </section>
        <section id="export-section" class="hidden">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="filename">Filename</label>
                    <input type="text" id="filename" value="vectorized" aria-label="Export filename" />
                </div>
                <div class="control-group">
                    <button id="export-svg" class="button">Export as SVG</button>
                    <button id="export-png" class="button">Export as PNG</button>
                </div>
                <div class="control-group">
                    <button id="save-project" class="button">Save Project</button>
                    <button id="load-project" class="button">Load Project</button>
                    <input type="file" id="project-upload" accept=".json" class="hidden" />
                </div>
            </div>
        </section>

        <section id="properties-section" class="hidden">
            <h3>Object Properties</h3>
            <div class="controls-grid">
                <div class="control-group">
                    <label for="fill-color-input">Fill Color (HEX)</label>
                    <input type="text" id="fill-color-input" maxlength="7" aria-label="Object fill color" />
                </div>
                <div class="control-group">
                    <label for="stroke-color-input">Stroke Color (HEX)</label>
                    <input type="text" id="stroke-color-input" maxlength="7" aria-label="Object stroke color" />
                </div>
                <div class="control-group">
                    <label for="object-opacity-slider">Opacity</label>
                    <input type="range" id="object-opacity-slider" min="0" max="1" step="0.01" value="1" aria-valuenow="1" aria-label="Object opacity" />
                </div>
                <div class="control-group">
                    <label for="object-stroke-width-slider">Stroke Width</label>
                    <input type="range" id="object-stroke-width-slider" min="1" max="20" value="1" aria-valuenow="1" aria-label="Object stroke width" />
                </div>
            </div>
        </section>

        <section id="layer-section">
            <h3>Layers</h3>
            <div class="controls-grid">
                <div class="control-group">
                    <label for="layer-select">Current Layer</label>
                    <select id="layer-select" aria-label="Select layer"></select>
                </div>
                <div class="control-group">
                    <button id="add-layer" class="button">Add Layer</button>
                    <button id="toggle-layer-visibility" class="button">Toggle Visibility</button>
                    <button id="toggle-layer-lock" class="button">Toggle Lock</button>
                </div>
            </div>
        </section>

        <section id="settings-section">
            <h3>Settings</h3>
            <div class="controls-grid">
                <div class="control-group">
                    <button id="theme-toggle" class="button">Toggle Theme</button>
                    <button id="high-contrast-toggle" class="button">High Contrast</button>
                    <button id="reset-session" class="button">Reset Session</button>
                </div>
                <div class="control-group">
                    <button id="debug-toggle" class="button">Toggle Debug</button>
                    <button id="help-toggle" class="button">Help</button>
                </div>
            </div>
        </section>

        <div id="preview-window" class="hidden"></div>
        <div id="debug-panel" style="display: none;">
            <h3>Debug Panel</h3>
            <pre id="svg-output"></pre>
            <button id="close-debug" class="button">Close</button>
        </div>
        <div id="help-modal" style="display: none;">
            <h3>Help - Doppleit Vector v2 Pro</h3>
            <p><strong>Tools:</strong> Use Pen (1), Rectangle (2), Circle (3), Text (4), or Select (S) to draw or edit objects.</p>
            <p><strong>Layers:</strong> Add, rename (double-click), toggle visibility/lock layers.</p>
            <p><strong>Color:</strong> Pick colors via wheel, sliders, or inputs (HEX/RGB/HSL).</p>
            <p><strong>Export:</strong> Save as SVG, PNG, or JSON project file.</p>
            <p><strong>Shortcuts:</strong> Undo (Ctrl+Z), Redo (Ctrl+Y), Escape to deselect.</p>
            <button id="close-help" class="button">Close</button>
        </div>
        <div id="tooltip" style="display: none;"></div>
    </div>

    <script nonce="doppleit">
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GRID_SIZE = 10;
        const VALID_TYPES = ['image/jpeg', 'image/png', 'image/svg+xml'];
        const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
        const SWATCH_LIMIT = 10;

        let currentTool = 'pen';
        let isDrawing = false;
        let currentPath = [];
        let startPos = null;
        let currentPos = null;
        let selectedObject = null;
        let isColorDragging = false;
        let snapToGridEnabled = true;
        let redrawTimeout;

        let currentColor = { h: 32, s: 100, l: 44, a: 1 };
        let settings = JSON.parse(localStorage.getItem('settings')) || { theme: 'dark', highContrast: false };
        let swatches = JSON.parse(localStorage.getItem('swatches')) || [];
        let undoStack = [JSON.stringify([{ objects: [], visible: true, locked: false, name: 'Layer 1' }])];
        let redoStack = [];

        class LayerManager {
            constructor() {
                this.layers = [{ objects: [], visible: true, locked: false, name: 'Layer 1' }];
                this.currentLayerIndex = 0;
            }

            addLayer() {
                this.layers.push({ objects: [], visible: true, locked: false, name: `Layer ${this.layers.length + 1}` });
                this.currentLayerIndex = this.layers.length - 1;
                updateLayerSelect();
                drawCanvas();
            }

            setActiveLayer(index) {
                this.currentLayerIndex = index;
                updateLayerSelect();
                drawCanvas();
            }

            renameLayer(index, name) {
                this.layers[index].name = name;
                updateLayerSelect();
            }

            toggleVisibility(index) {
                this.layers[index].visible = !this.layers[index].visible;
                updateLayerSelect();
                drawCanvas();
            }

            toggleLock(index) {
                this.layers[index].locked = !this.layers[index].locked;
                updateLayerSelect();
                drawCanvas();
            }

            addObject(obj) {
                if (!this.layers[this.currentLayerIndex].locked) {
                    this.layers[this.currentLayerIndex].objects.push(obj);
                    saveState();
                    drawCanvas();
                }
            }

            updateObject(index, obj) {
                this.layers[this.currentLayerIndex].objects[index] = obj;
                saveState();
                drawCanvas();
            }

            deleteObject(index) {
                this.layers[this.currentLayerIndex].objects.splice(index, 1);
                saveState();
                drawCanvas();
            }

            getActiveObjects() {
                return this.layers[this.currentLayerIndex].objects;
            }

            getVisibleObjects() {
                return this.layers
                    .filter(layer => layer.visible)
                    .flatMap(layer => layer.objects);
            }
        }

        let layerManager = new LayerManager();

        function drawColorWheel(ctx) {
            const centerX = 50;
            const centerY = 50;
            const radius = 50;
            for (let angle = 0; angle < 360; angle += 1) {
                for (let r = 0; r < radius; r += 1) {
                    const rad = (angle * Math.PI) / 180;
                    const x = centerX + r * Math.cos(rad);
                    const y = centerY + r * Math.sin(rad);
                    ctx.fillStyle = `hsl(${angle}, ${(r / radius) * 100}%, ${currentColor.l}%)`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = l - c / 2;
            let r = 0, g = 0, b = 0;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return { r, g, b };
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
        }

        function rgbToHslObject(r, g, b) {
            const [h, s, l] = rgbToHsl(r, g, b);
            return { h, s, l };
        }

        function hslToRgbString(h, s, l, a = 1) {
            const { r, g, b } = hslToRgb(h, s, l);
            return `rgba(<span class="math-inline">\{r\},</span>{g},<span class="math-inline">\{b\},</span>{a})`;
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return { r, g, b };
        }

        function rgbToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function hexToHsl(hex) {
            const { r, g, b } = hexToRgb(hex);
            return rgbToHslObject(r, g, b);
        }

        function hslToHex(h, s, l) {
            const { r, g, b } = hslToRgb(h, s, l);
            return rgbToHex(r, g, b);
        }

        function updateColorInputs() {
            const { r, g, b } = hslToRgb(currentColor.h, currentColor.s, currentColor.l);
            document.getElementById('hex-input').value = rgbToHex(r, g, b);
            document.getElementById('rgb-input').value = `<span class="math-inline">\{r\},</span>{g},${b}`;
            document.getElementById('hsl-input').value = `<span class="math-inline">\{Math\.round\(currentColor\.h\)\},</span>{Math.round(currentColor.s)}%,${Math.round(currentColor.l)}%`;
            document.getElementById('native-picker').value = rgbToHex(r, g, b);
            document.getElementById('lightness-slider').value = currentColor.l;
            document.getElementById('lightness-slider').setAttribute('aria-valuenow', currentColor.l);
            document.getElementById('opacity-slider').value = currentColor.a;
            document.getElementById('opacity-slider').setAttribute('aria-valuenow', currentColor.a);
            drawColorWheel(document.getElementById('color-wheel').getContext('2d'));
        }

        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-section');
            if (selectedObject) {
                panel.classList.remove('hidden');
                document.getElementById('fill-color-input').value = selectedObject.fill.includes('url') ? '#000000' : selectedObject.fill;
                document.getElementById('stroke-color-input').value = selectedObject.stroke;
                document.getElementById('object-opacity-slider').value = selectedObject.opacity ||
1;
                document.getElementById('object-opacity-slider').setAttribute('aria-valuenow', selectedObject.opacity || 1);
                document.getElementById('object-stroke-width-slider').value = selectedObject.strokeWidth || 1;
                document.getElementById('object-stroke-width-slider').setAttribute('aria-valuenow', selectedObject.strokeWidth || 1);
            } else {
                panel.classList.add('hidden');
            }
        }

        async function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        function snapToGrid(value) {
            if (snapToGridEnabled) {
                return Math.round(value / GRID_SIZE) * GRID_SIZE;
            }
            return value;
        }

        function drawCanvas() {
            console.log('Drawing canvas with objects:', layerManager.getVisibleObjects());
            cancelAnimationFrame(redrawTimeout);
            redrawTimeout = requestAnimationFrame(() => {
                const ctx = document.getElementById('drawing-canvas').getContext('2d');
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                layerManager.getVisibleObjects().forEach(obj => {
                    ctx.globalAlpha = obj.opacity || 1;
                    ctx.fillStyle = document.getElementById('fill-toggle').checked ? obj.fill : 'transparent';
                    ctx.strokeStyle = obj.stroke;
                    ctx.lineWidth = Math.max(0.1, obj.strokeWidth);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    if (obj.strokeStyle === 'dashed') {
                        ctx.setLineDash([5, 5]);
                    } else if (obj.strokeStyle === 'dotted') {
                        ctx.setLineDash([2, 2]);
                    } else {
                        ctx.setLineDash([]);
                    }

                    switch (obj.type) {
                        case 'path':
                            ctx.beginPath();
                            obj.points.forEach((p, i) => {
                                const x = snapToGrid(p.x);
                                const y = snapToGrid(p.y);
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });
                            ctx.stroke();
                            if (document.getElementById('fill-toggle').checked && obj.fill !== 'transparent') {
                                ctx.fill();
                            }
                            break;
                        case 'rect':
                            const x = snapToGrid(Math.min(obj.x, obj.x + obj.width));
                            const y = snapToGrid(Math.min(obj.y, obj.y + obj.height));
                            const width = snapToGrid(Math.abs(obj.width));
                            const height = snapToGrid(Math.abs(obj.height));
                            ctx.fillRect(x, y, width, height);
                            ctx.strokeRect(x, y, width, height);
                            break;
                        case 'circle':
                            const cx = snapToGrid(obj.cx);
                            const cy = snapToGrid(obj.cy);
                            const r = snapToGrid(obj.r);
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'text':
                            ctx.font = `${obj.size || 16}px Inter`;
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';
                            ctx.fillText(obj.text, snapToGrid(obj.x), snapToGrid(obj.y));
                            ctx.strokeText(obj.text, snapToGrid(obj.x), snapToGrid(obj.y));
                            break;
                        case 'image':
                            if (obj.image) {
                                ctx.drawImage(obj.image, snapToGrid(obj.x), snapToGrid(obj.y), snapToGrid(obj.width), snapToGrid(obj.height));
                            }
                            break;
                    }
                });

                if (selectedObject) {
                    ctx.globalAlpha = 1;
                    ctx.strokeStyle = '#00f';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    switch (selectedObject.type) {
                        case 'path':
                            ctx.beginPath();
                            selectedObject.points.forEach((p, i) => {
                                const x = snapToGrid(p.x);
                                const y = snapToGrid(p.y);
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });
                            ctx.stroke();
                            break;
                        case 'rect':
                            const x = snapToGrid(Math.min(selectedObject.x, selectedObject.x + selectedObject.width));
                            const y = snapToGrid(Math.min(selectedObject.y, selectedObject.y + selectedObject.height));
                            const width = snapToGrid(Math.abs(selectedObject.width));
                            const height = snapToGrid(Math.abs(selectedObject.height));
                            ctx.strokeRect(x, y, width, height);
                            break;
                        case 'circle':
                            const cx = snapToGrid(selectedObject.cx);
                            const cy = snapToGrid(selectedObject.cy);
                            const r = snapToGrid(selectedObject.r);
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                            ctx.stroke();
                            break;
                        case 'text':
                            const textWidth = ctx.measureText(selectedObject.text).width;
                            const sx = snapToGrid(selectedObject.x);
                            const sy = snapToGrid(selectedObject.y);
                            ctx.strokeRect(sx, sy, textWidth, selectedObject.size || 16);
                            break;
                        case 'image':
                            ctx.strokeRect(snapToGrid(selectedObject.x), snapToGrid(selectedObject.y), snapToGrid(selectedObject.width), snapToGrid(selectedObject.height));
                            break;
                    }
                    ctx.setLineDash([]);
                }

                if (snapToGridEnabled) {
                    drawGrid(ctx);
                }
            });
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 0.5;
            for (let i = GRID_SIZE; i < CANVAS_WIDTH; i += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let i = GRID_SIZE; i < CANVAS_HEIGHT; i += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(CANVAS_WIDTH, i);
                ctx.stroke();
            }
        }

        function saveState() {
            undoStack.push(JSON.stringify(layerManager.layers.map(layer => ({ ...layer, objects: layer.objects.map(o => ({ ...o })) }))));
            redoStack.length = 0;
            if (undoStack.length > 50) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length > 1) {
                redoStack.push(undoStack.pop());
                const previousState = JSON.parse(undoStack[undoStack.length - 1]);
                layerManager.layers = previousState.map(layerData => ({ ...layerData, objects: layerData.objects.map(o => ({ ...o })) }));
                updateLayerSelect();
                drawCanvas();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push(redoStack.pop());
                const nextState = JSON.parse(undoStack[undoStack.length - 1]);
                layerManager.layers = nextState.map(layerData => ({ ...layerData, objects: layerData.objects.map(o => ({ ...o })) }));
                updateLayerSelect();
                drawCanvas();
            }
        }

        function handleMouseDown(e) {
            isDrawing = true;
            startPos = { x: e.offsetX, y: e.offsetY };
            currentPos = { ...startPos };
            if (currentTool === 'pen') {
                currentPath = [{ ...startPos }];
                layerManager.addObject({ type: 'path', points: currentPath, stroke: hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a), fill: 'transparent', strokeStyle: document.getElementById('stroke-style').value, strokeWidth: parseFloat(document.getElementById('stroke-width-slider').value) });
                selectedObject = layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1];
            } else if (currentTool === 'rect') {
                layerManager.addObject({ type: 'rect', x: startPos.x, y: startPos.y, width: 0, height: 0, fill: document.getElementById('fill-toggle').checked ? hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a) : 'transparent', stroke: hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a), strokeStyle: document.getElementById('stroke-style').value, strokeWidth: parseFloat(document.getElementById('stroke-width-slider').value), opacity: parseFloat(document.getElementById('opacity-slider').value) });
                selectedObject = layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1];
            } else if (currentTool === 'circle') {
                layerManager.addObject({ type: 'circle', cx: startPos.x, cy: startPos.y, r: 0, fill: document.getElementById('fill-toggle').checked ? hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a) : 'transparent', stroke: hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a), strokeStyle: document.getElementById('stroke-style').value, strokeWidth: parseFloat(document.getElementById('stroke-width-slider').value), opacity: parseFloat(document.getElementById('opacity-slider').value) });
                selectedObject = layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1];
            } else if (currentTool === 'text') {
                const textInput = document.getElementById('text-input');
                textInput.style.left = `${startPos.x}px`;
                textInput.style.top = `${startPos.y}px`;
                textInput.classList.remove('hidden');
                textInput.focus();
                textInput.onblur = () => {
                    layerManager.addObject({ type: 'text', text: textInput.value, x: startPos.x, y: startPos.y, fill: hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a), stroke: hslToRgbString(currentColor.h, currentColor.s, currentColor.l, currentColor.a), strokeStyle: document.getElementById('stroke-style').value, strokeWidth: parseFloat(document.getElementById('stroke-width-slider').value), opacity: parseFloat(document.getElementById('opacity-slider').value) });
                    textInput.value = '';
                    textInput.classList.add('hidden');
                    textInput.onblur = null;
                    selectedObject = null;
                    drawCanvas();
                };
            } else if (currentTool === 'select') {
                selectedObject = layerManager.getVisibleObjects().findLast(obj => {
                    if (obj.type === 'rect') {
                        return e.offsetX >= Math.min(obj.x, obj.x + obj.width) && e.offsetX <= Math.max(obj.x, obj.x + obj.width) &&
                               e.offsetY >= Math.min(obj.y, obj.y + obj.height) && e.offsetY <= Math.max(obj.y, obj.y + obj.height);
                    } else if (obj.type === 'circle') {
                        const dx = e.offsetX - obj.cx;
                        const dy = e.offsetY - obj.cy;
                        return dx * dx + dy * dy <= obj.r * obj.r;
                    } else if (obj.type === 'path') {
                        // Basic point-in-polygon check (can be improved)
                        return obj.points.some(p => Math.abs(e.offsetX - p.x) < 5 && Math.abs(e.offsetY - p.y) < 5);
                    } else if (obj.type === 'text') {
                        const textWidth = document.getElementById('drawing-canvas').getContext('2d').measureText(obj.text).width;
                        return e.offsetX >= obj.x && e.offsetX <= obj.x + textWidth && e.offsetY >= obj.y && e.offsetY <= obj.y + (obj.size || 16);
                    } else if (obj.type === 'image') {
                        return e.offsetX >= obj.x && e.offsetX <= obj.x + obj.width && e.offsetY >= obj.y && e.offsetY <= obj.y + obj.height;
                    }
                    return false;
                });
                updatePropertiesPanel();
                drawCanvas();
            } else if (currentTool === 'eyedropper') {
                const ctx = document.getElementById('drawing-canvas').getContext('2d');
                const pixelData = ctx.getImageData(e.offsetX, e.offsetY, 1, 1).data;
                currentColor = rgbToHslObject(pixelData[0], pixelData[1], pixelData[2]);
                updateColorInputs();
            }
        }

        function handleMouseMove(e) {
            if (!isDrawing) return;
            currentPos = { x: e.offsetX, y: e.offsetY };
            if (currentTool === 'pen') {
                currentPath.push({ ...currentPos });
                layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1].points = [...currentPath];
            } else if (currentTool === 'rect') {
                const obj = layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1];
                obj.width = currentPos.x - startPos.x;
                obj.height = currentPos.y - startPos.y;
            } else if (currentTool === 'circle') {
                const obj = layerManager.getActiveObjects()[layerManager.getActiveObjects().length - 1];
                const dx = currentPos.x - startPos.x;
                const dy = currentPos.y - startPos.y;
                obj.r = Math.sqrt(dx * dx + dy * dy);
            }
            drawCanvas();
        }

        function handleMouseUp() {
            if (!isDrawing) return;
            isDrawing = false;
            startPos = null;
            currentPos = null;
            if (currentTool !== 'text') {
                saveState();
            }
        }

        function handleColorWheelMouseDown(e) {
            isColorDragging = true;
            updateCurrentColorFromWheel(e.offsetX, e.offsetY);
        }

        function handleColorWheelMouseMove(e) {
            if (!isColorDragging) return;
            updateCurrentColorFromWheel(e.offsetX, e.offsetY);
        }

        function handleColorWheelMouseUp() {
            isColorDragging = false;
            addToSwatches(hslToHex(currentColor.h, currentColor.s, currentColor.l));
        }

        function updateCurrentColorFromWheel(x, y) {
            const centerX = 50;
            const centerY = 50;
            const dx = x - centerX;
            const dy = y - centerY;
            const angleRad = Math.atan2(dy, dx);
            let hue = (angleRad * 180 / Math.PI + 360) % 360;
            const saturation = Math.min(100, Math.sqrt(dx * dx + dy * dy) * 2);
            currentColor = { h: hue, s: saturation, l: currentColor.l, a: currentColor.a };
            updateColorInputs();
        }

        function handleLightnessChange() {
            currentColor.l = parseInt(this.value);
            document.getElementById('lightness-value').textContent = `${this.value}%`;
            this.setAttribute('aria-valuenow', this.value);
            updateColorInputs();
        }

        function handleOpacityChange() {
            currentColor.a = parseFloat(this.value);
            document.getElementById('opacity-value').textContent = `${Math.round(this.value * 100)}%`;
            this.setAttribute('aria-valuenow', this.value);
            updateColorInputs();
        }

        function handleStrokeWidthChange() {
            document.getElementById('stroke-width-value').textContent = `${this.value}px`;
            this.setAttribute('aria-valuenow',
this.value);
        }

        function handleHexInput() {
            const hex = this.value;
            if (/^#?[0-9A-Fa-f]{3,6}$/.test(hex)) {
                currentColor = { ...hexToHsl(hex), a: currentColor.a };
                updateColorInputs();
            }
        }

        function handleRgbInput() {
            const rgbString = this.value.split(',').map(s => parseInt(s.trim()));
            if (rgbString.length === 3 && rgbString.every(n => n >= 0 && n <= 255)) {
                currentColor = { ...rgbToHslObject(rgbString[0], rgbString[1], rgbString[2]), a: currentColor.a };
                updateColorInputs();
            }
        }

        function handleHslInput() {
            const hslString = this.value.split(',').map(s => s.trim());
            if (hslString.length === 3) {
                const h = parseInt(hslString[0]);
                const s = parseInt(hslString[1].replace('%', ''));
                const l = parseInt(hslString[2].replace('%', ''));
                if (!isNaN(h) && h >= 0 && h <= 360 && !isNaN(s) && s >= 0 && s <= 100 && !isNaN(l) && l >= 0 && l <= 100) {
                    currentColor = { h, s, l, a: currentColor.a };
                    updateColorInputs();
                }
            }
        }

        function handleNativePickerChange() {
            const hex = this.value;
            currentColor = { ...hexToHsl(hex), a: currentColor.a };
            updateColorInputs();
            addToSwatches(hex);
        }

        function openSystemColorPicker() {
            document.getElementById('native-picker').click();
        }

        function toggleFill() {
            drawCanvas();
        }

        function changeTool(e) {
            document.querySelectorAll('#drawing-tools .button').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            currentTool = e.target.id.replace('-tool', '');
            document.body.style.cursor = currentTool === 'eyedropper' ? 'crosshair' : 'default';
            if (currentTool === 'text') {
                document.getElementById('drawing-canvas').style.cursor = 'text';
            } else {
                document.getElementById('drawing-canvas').style.cursor = 'crosshair';
            }
        }

        function addToSwatches(color) {
            if (!swatches.includes(color)) {
                swatches.push(color);
                if (swatches.length > SWATCH_LIMIT) {
                    swatches.shift();
                }
                localStorage.setItem('swatches', JSON.stringify(swatches));
                renderSwatches();
            }
        }

        function renderSwatches() {
            const swatchesContainer = document.getElementById('swatches');
            swatchesContainer.innerHTML = '';
            swatches.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('swatch');
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => {
                    currentColor = { ...hexToHsl(color), a: currentColor.a };
                    updateColorInputs();
                });
                swatchesContainer.appendChild(swatch);
            });
        }

        function handleFileUpload() {
            const file = this.files[0];
            if (file) {
                if (!VALID_TYPES.includes(file.type)) {
                    document.getElementById('error-message').textContent = 'Invalid file type. Only JPG, PNG, and SVG are allowed.';
                    document.getElementById('error-message').classList.remove('hidden');
                    return;
                }
                if (file.size > MAX_FILE_SIZE) {
                    document.getElementById('error-message').textContent = 'File size exceeds the limit of 5MB.';
                    document.getElementById('error-message').classList.remove('hidden');
                    return;
                }

                document.getElementById('loading-message').classList.remove('hidden');
                document.getElementById('progress-bar').classList.remove('hidden');
                document.getElementById('upload-instructions').classList.add('hidden');
                document.getElementById('error-message').classList.add('hidden');
                document.getElementById('confirmation-message').classList.add('hidden');
                document.getElementById('thumbnail-preview').classList.add('hidden');

                const reader = new FileReader();
                reader.onloadstart = () => {
                    document.getElementById('progress-fill').style.width = '0%';
                };
                reader.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        document.getElementById('progress-fill').style.width = `${percentComplete}%`;
                    }
                };
                reader.onload = async (event) => {
                    document.getElementById('loading-message').classList.add('hidden');
                    document.getElementById('progress-bar').classList.add('hidden');
                    document.getElementById('confirmation-message').classList.remove('hidden');

                    if (file.type === 'image/svg+xml') {
                        const svgData = event.target.result;
                        const img = new Image();
                        img.onload = () => {
                            layerManager.addObject({ type: 'image', image: img, x: 0, y: 0, width: img.width, height: img.height });
                            drawCanvas();
                            document.getElementById('canvas-section').classList.remove('hidden');
                            document.getElementById('export-section').classList.remove('hidden');
                        };
                        img.src = svgData;
                        document.getElementById('thumbnail-preview').src = 'data:image/svg+xml;base64,' + btoa(svgData);
                        document.getElementById('thumbnail-preview').classList.remove('hidden');
                    } else {
                        const img = await loadImage(file);
                        layerManager.addObject({ type: 'image', image: img, x: 0, y: 0, width: img.width, height: img.height });
                        drawCanvas();
                        document.getElementById('canvas-section').classList.remove('hidden');
                        document.getElementById('export-section').classList.remove('hidden');
                        document.getElementById('thumbnail-preview').src = img.src;
                        document.getElementById('thumbnail-preview').classList.remove('hidden');
                    }
                };
                reader.onerror = () => {
                    document.getElementById('loading-message').classList.add('hidden');
                    document.getElementById('progress-bar').classList.add('hidden');
                    document.getElementById('error-message').textContent = 'Error loading file.';
                    document.getElementById('error-message').classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            }
        }

        function handleBrowseButtonClick() {
            document.getElementById('file-upload').click();
        }

        function toggleSnapGrid() {
            snapToGridEnabled = this.checked;
            drawCanvas();
        }

        function exportSVG() {
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', CANVAS_WIDTH);
            svg.setAttribute('height', CANVAS_HEIGHT);

            layerManager.getVisibleObjects().forEach(obj => {
                if (obj.type === 'path') {
                    const path = document.createElementNS(svgNS, 'path');
                    const d = obj.points.map((p, i) => (i === 0 ? `M${p.x},${p.y}` : `L${p.x},${p.y}`)).join(' ');
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', obj.stroke);
                    path.setAttribute('fill', document.getElementById('fill-toggle').checked ? obj.fill : 'none');
                    path.setAttribute('stroke-width', obj.strokeWidth);
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    if (obj.strokeStyle === 'dashed') {
                        path.setAttribute('stroke-dasharray', '5, 5');
                    } else if (obj.strokeStyle === 'dotted') {
                        path.setAttribute('stroke-dasharray', '2, 2');
                    }
                    svg.appendChild(path);
                } else if (obj.type === 'rect') {
                    const rect = document.createElementNS(svgNS, 'rect');
                    rect.setAttribute('x', Math.min(obj.x, obj.x + obj.width));
                    rect.setAttribute('y', Math.min(obj.y, obj.y + obj.height));
                    rect.setAttribute('width', Math.abs(obj.width));
                    rect.setAttribute('height', Math.abs(obj.height));
                    rect.setAttribute('fill', document.getElementById('fill-toggle').checked ? obj.fill : 'none');
                    rect.setAttribute('stroke', obj.stroke);
                    rect.setAttribute('stroke-width', obj.strokeWidth);
                    svg.appendChild(rect);
                } else if (obj.type === 'circle') {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', obj.cx);
                    circle.setAttribute('cy', obj.cy);
                    circle.setAttribute('r', obj.r);
                    circle.setAttribute('fill', document.getElementById('fill-toggle').checked ? obj.fill : 'none');
                    circle.setAttribute('stroke', obj.stroke);
                    circle.setAttribute('stroke-width', obj.strokeWidth);
                    svg.appendChild(circle);
                } else if (obj.type === 'text') {
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', obj.x);
                    text.setAttribute('y', obj.y);
                    text.style.fontFamily = 'Inter, sans-serif';
                    text.style.fontSize = `${obj.size || 16}px`;
                    text.setAttribute('fill', obj.fill);
                    text.setAttribute('stroke', obj.stroke);
                    text.setAttribute('stroke-width', obj.strokeWidth);
                    text.textContent = obj.text;
                    svg.appendChild(text);
                } else if (obj.type === 'image' && obj.image) {
                    const image = document.createElementNS(svgNS, 'image');
                    image.setAttribute('href', obj.image.src);
                    image.setAttribute('x', obj.x);
                    image.setAttribute('y', obj.y);
                    image.setAttribute('width', obj.width);
                    image.setAttribute('height', obj.height);
                    svg.appendChild(image);
                }
                if (obj.opacity !== undefined && obj.opacity !== 1) {
                    if (obj.type === 'path' || obj.type === 'rect' || obj.type === 'circle' || obj.type === 'text' || obj.type === 'image') {
                        const lastChild = svg.lastChild;
                        lastChild.setAttribute('opacity', obj.opacity);
                    }
                }
            });

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svg);
            document.getElementById('svg-output').textContent = svgString;
            document.getElementById('debug-panel').style.display = 'block';

            const filename = document.getElementById('filename').value + '.svg';
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportPNG() {
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getComputedStyle(document.body).backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            layerManager.getVisibleObjects().forEach(obj => {
                ctx.globalAlpha = obj.opacity || 1;
                ctx.fillStyle = document.getElementById('fill-toggle').checked ? obj.fill : 'transparent';
                ctx.strokeStyle = obj.stroke;
                ctx.lineWidth = Math.max(0.1, obj.strokeWidth);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                if (obj.strokeStyle === 'dashed') {
                    ctx.setLineDash([5, 5]);
                } else if (obj.strokeStyle === 'dotted') {
                    ctx.setLineDash([2, 2]);
                } else {
                    ctx.setLineDash([]);
                }

                switch (obj.type) {
                    case 'path':
                        ctx.beginPath();
                        obj.points.forEach((p, i) => {
                            ctx.lineTo(p.x, p.y);
                            if (i === 0) ctx.moveTo(p.x, p.y);
                        });
                        ctx.stroke();
                        if (document.getElementById('fill-toggle').checked && obj.fill !== 'transparent') ctx.fill();
                        break;
                    case 'rect':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(obj.cx, obj.cy, obj.r, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 'text':
                        ctx.font = `${obj.size || 16}px Inter`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(obj.text, obj.x, obj.y);
                        ctx.strokeText(obj.text, obj.x, obj.y);
                        break;
                    case 'image':
                        if (obj.image) {
                            ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                        }
                        break;
                }
            });
            const filename = document.getElementById('filename').value + '.png';
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function saveProject() {
            const projectData = {
                layers: layerManager.layers,
                settings: settings,
                swatches: swatches,
                currentColor: currentColor
            };
            const jsonString = JSON.stringify(projectData);
            const filename = document.getElementById('filename').value + '.json';
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            document.getElementById('project-upload').click();
        }

        function handleProjectUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        layerManager.layers = projectData.layers.map(layerData => ({ ...layerData, objects: layerData.objects.map(o => ({ ...o })) }));
                        settings = projectData.settings || { theme: 'dark', highContrast: false };
                        swatches = projectData.swatches || [];
                        currentColor = projectData.currentColor || { h: 32, s: 100, l: 44, a: 1 };
                        localStorage.setItem('settings', JSON.stringify(settings));
                        localStorage.setItem('swatches', JSON.stringify(swatches));
                        applySettings();
                        renderSwatches();
                        updateColorInputs();
                        updateLayerSelect();
                        drawCanvas();
                        document.getElementById('canvas-section').classList.remove('hidden');
                        document.getElementById('export-section').classList.remove('hidden');
                    } catch (error) {
                        alert('Error loading project file.');
                        console.error('Error loading project:', error);
                    }
                };
                reader.readAsText(file);
                e.target.value = null; // Reset file input
            }
        }

        function updateLayerSelect() {
            const layerSelect = document.getElementById('layer-select');
layerSelect.innerHTML = '';
            layerManager.layers.forEach((layer, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = layer.name;
                option.selected = index === layerManager.currentLayerIndex;
                layerSelect.appendChild(option);
            });
        }

        function handleLayerSelectChange() {
            layerManager.setActiveLayer(parseInt(this.value));
        }

        function addLayer() {
            layerManager.addLayer();
        }

        function toggleLayerVisibility() {
            const index = parseInt(document.getElementById('layer-select').value);
            layerManager.toggleVisibility(index);
        }

        function toggleLayerLock() {
            const index = parseInt(document.getElementById('layer-select').value);
            layerManager.toggleLock(index);
        }

        function applySettings() {
            document.documentElement.setAttribute('data-theme', settings.theme);
            document.documentElement.setAttribute('data-high-contrast', settings.highContrast);
        }

        function toggleTheme() {
            settings.theme = settings.theme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('settings', JSON.stringify(settings));
            applySettings();
        }

        function toggleHighContrast() {
            settings.highContrast = !settings.highContrast;
            localStorage.setItem('settings', JSON.stringify(settings));
            applySettings();
        }

        function resetSession() {
            localStorage.removeItem('settings');
            localStorage.removeItem('swatches');
            settings = { theme: 'dark', highContrast: false };
            swatches = [];
            currentColor = { h: 32, s: 100, l: 44, a: 1 };
            layerManager = new LayerManager();
            undoStack = [JSON.stringify([{ objects: [], visible: true, locked: false, name: 'Layer 1' }])];
            redoStack = [];
            applySettings();
            renderSwatches();
            updateColorInputs();
            updateLayerSelect();
            drawCanvas();
            document.getElementById('canvas-section').classList.add('hidden');
            document.getElementById('export-section').classList.add('hidden');
        }

        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debug-panel');
            debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
        }

        function closeDebugPanel() {
            document.getElementById('debug-panel').style.display = 'none';
        }

        function toggleHelpModal() {
            const helpModal = document.getElementById('help-modal');
            helpModal.style.display = helpModal.style.display === 'none' ? 'block' : 'none';
        }

        function closeHelpModal() {
            document.getElementById('help-modal').style.display = 'none';
        }

        function deleteSelectedObject() {
            if (selectedObject) {
                const layerIndex = layerManager.layers.findIndex(layer => layer.objects.includes(selectedObject));
                if (layerIndex !== -1) {
                    const objectIndex = layerManager.layers[layerIndex].objects.indexOf(selectedObject);
                    layerManager.deleteObject(objectIndex);
                    selectedObject = null;
                    updatePropertiesPanel();
                    drawCanvas();
                }
            }
        }

        document.getElementById('color-wheel').addEventListener('mousedown', handleColorWheelMouseDown);
        document.addEventListener('mousemove', handleColorWheelMouseMove);
        document.addEventListener('mouseup', handleColorWheelMouseUp);

        document.getElementById('drawing-canvas').addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        document.querySelectorAll('#drawing-tools .button').forEach(button => {
            button.addEventListener('click', changeTool);
        });

        document.getElementById('lightness-slider').addEventListener('input', handleLightnessChange);
        document.getElementById('opacity-slider').addEventListener('input', handleOpacityChange);
        document.getElementById('stroke-width-slider').addEventListener('input', handleStrokeWidthChange);
        document.getElementById('hex-input').addEventListener('input', handleHexInput);
        document.getElementById('rgb-input').addEventListener('input', handleRgbInput);
        document.getElementById('hsl-input').addEventListener('input', handleHslInput);
        document.getElementById('native-picker').addEventListener('change', handleNativePickerChange);
        document.getElementById('system-picker').addEventListener('click', openSystemColorPicker);
        document.getElementById('fill-toggle').addEventListener('change', toggleFill);
        document.getElementById('file-upload').addEventListener('change', handleFileUpload);
        document.getElementById('browse-button').addEventListener('click', handleBrowseButtonClick);
        document.getElementById('snap-grid').addEventListener('change', toggleSnapGrid);
        document.getElementById('export-svg').addEventListener('click', exportSVG);
        document.getElementById('export-png').addEventListener('click', exportPNG);
        document.getElementById('save-project').addEventListener('click', saveProject);
        document.getElementById('load-project').addEventListener('click', loadProject);
        document.getElementById('project-upload').addEventListener('change', handleProjectUpload);
        document.getElementById('layer-select').addEventListener('change', handleLayerSelectChange);
        document.getElementById('add-layer').addEventListener('click', addLayer);
        document.getElementById('toggle-layer-visibility').addEventListener('click', toggleLayerVisibility);
        document.getElementById('toggle-layer-lock').addEventListener('click', toggleLayerLock);
        document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
        document.getElementById('high-contrast-toggle').addEventListener('click', toggleHighContrast);
        document.getElementById('reset-session').addEventListener('click', resetSession);
        document.getElementById('debug-toggle').addEventListener('click', toggleDebugPanel);
        document.getElementById('close-debug').addEventListener('click', closeDebugPanel);
        document.getElementById('help-toggle').addEventListener('click', toggleHelpModal);
        document.getElementById('close-help').addEventListener('click', closeHelpModal);
        document.getElementById('delete').addEventListener('click', deleteSelectedObject);

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                redo();
            } else if (e.key === 'Escape') {
                selectedObject = null;
                updatePropertiesPanel();
                drawCanvas();
            } else if (document.activeElement !== document.getElementById('text-input')) {
                switch (e.key) {
                    case '1': document.getElementById('pen-tool').click(); break;
                    case '2': document.getElementById('rect-tool').click(); break;
                    case '3': document.getElementById('circle-tool').click(); break;
                    case '4': document.getElementById('text-tool').click(); break;
                    case 's': document.getElementById('select-tool').click(); break;
                    case 'Delete': deleteSelectedObject(); break;
                }
            }
        });

        applySettings();
        renderSwatches();
        updateColorInputs();
        updateLayerSelect();
        drawCanvas();
    </script>
</body>
</html>